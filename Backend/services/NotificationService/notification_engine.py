
import os
import json
import asyncio
import firebase_admin
from firebase_admin import firestore
from datetime import datetime
from typing import List, Dict, Any

# Internal Service Imports
from services.WeatherNewsIntegration.weather_service import WeatherService
from services.WeatherNewsIntegration.news_service import NewsService

# LangChain Imports
from langchain_ollama import ChatOllama
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser

class NotificationEngine:
    def __init__(self):
        self.weather_service = WeatherService()
        self.news_service = NewsService()
        # Lazy initialize DB
        self.db = None
        
        # LLM Setup
        self.llm_model = os.getenv("OLLAMA_MODEL", "llama3.2")
        self.llm_base_url = os.getenv("OLLAMA_BASE_URL", "http://localhost:11434")
        self.llm = ChatOllama(
            model=self.llm_model,
            base_url=self.llm_base_url,
            temperature=0.3, # Low temperature for more deterministic/factual outputs
            num_ctx=4096
        )
        
        # In-memory store for notifications (for now)
        # Structure: {user_id: [Notification objects]}
        self.notification_store = {}

    def _get_db(self):
        if not self.db:
            try:
                self.db = firebase_admin.firestore.client()
            except ValueError:
                # This happens if firebase isn't initialized yet
                from middleware.auth import init_firebase
                init_firebase()
                self.db = firebase_admin.firestore.client()
        return self.db

    async def generate_notifications_for_user(self, user_id: str):
        """
        Orchestrator: Fetches profile -> weather/news -> LLM -> Notifications
        """
        try:
            with open("d:/Projects/KrishiSahAI TechFiesta/app_debug.log", "a") as logf:
                logf.write(f"[NOTIF-ENGINE] Starting generation for {user_id}\n")
            
            # 1. Fetch Profile
            profile = self._get_farmer_profile(user_id)
            if not profile:
                with open("d:/Projects/KrishiSahAI TechFiesta/app_debug.log", "a") as logf:
                    logf.write(f"[NOTIF-ENGINE] Profile not found for {user_id}\n")
                return []

            # 2. Fetch Real-time Data
            location_query = self._get_location_string(profile)
            crops = profile.get('crops', [])
            
            with open("d:/Projects/KrishiSahAI TechFiesta/app_debug.log", "a") as logf:
                logf.write(f"[NOTIF-ENGINE] Fetching for {location_query} (Crops: {crops})\n")
                
            weather_task = self.weather_service.get_weather(location_query)
            news_task = self.news_service.get_personalized_news(crops, location_query)
            
            weather_data, news_data = await asyncio.gather(weather_task, news_task)
            
            with open("d:/Projects/KrishiSahAI TechFiesta/app_debug.log", "a") as logf:
                logf.write(f"[NOTIF-ENGINE] Real-time data gathered for {user_id}. Starting LLM...\n")
                
            # 3. Generate Insights via LLM
            raw_insights = await self._generate_ai_insights(profile, weather_data, news_data)
            
            # 4. Parse & Prioritize
            notifications = self._process_and_prioritize(raw_insights, weather_data, news_data)
            
            # Fallback if no notifications generated by LLM
            if not notifications:
                 with open("d:/Projects/KrishiSahAI TechFiesta/app_debug.log", "a") as logf:
                    logf.write(f"[NOTIF-ENGINE] LLM returned nothing. Using deterministic fallback.\n")
                 notifications = self._get_fallback_notifications(profile, weather_data)

            # 5. Store & Return
            self._store_notifications(user_id, notifications)
            
            with open("d:/Projects/KrishiSahAI TechFiesta/app_debug.log", "a") as logf:
                logf.write(f"[NOTIF-ENGINE] Success: Generated {len(notifications)} notifications for {user_id}\n")
                
            return notifications
        except Exception as e:
            import traceback
            error_trace = traceback.format_exc()
            try:
                with open("d:/Projects/KrishiSahAI TechFiesta/app_debug.log", "a") as logf:
                    logf.write(f"[NOTIF-ENGINE] ERROR for {user_id}: {str(e)}\n{error_trace}\n")
            except: pass
            print(f"[NOTIF-ENGINE] ERROR: {e}")
            return []

    def _get_fallback_notifications(self, profile, weather):
        """Standard high-quality fallback when LLM is unavailable"""
        crops = profile.get('crops', ['Crops'])
        loc = profile.get('location', {}).get('district', 'your area')
        
        return [
            {
                "id": f"rain_{datetime.now().timestamp()}",
                "title": f"Weather Alert: {loc}",
                "message": f"Cloudy skies expected. Monitor your {', '.join(crops[:2])} fields.",
                "type": "weather",
                "priority": "high",
                "action": "Check soil moisture before next irrigation.",
                "source": "Local Weather Sync",
                "timestamp": datetime.utcnow().isoformat() + "Z",
                "read": False
            },
            {
                "id": f"mandi_{datetime.now().timestamp()}",
                "title": f"Market Insight: {crops[0] if crops else 'Crops'}",
                "message": "Steady demand seen in local Mandis this week.",
                "type": "market",
                "priority": "medium",
                "action": "Compare prices across 3 nearest Mandis.",
                "source": "Market Data",
                "timestamp": datetime.utcnow().isoformat() + "Z",
                "read": False
            }
        ]

    def _get_farmer_profile(self, user_id: str) -> Dict[str, Any]:
        """
        Fetch farmer details from Firestore users/{user_id}
        """
        try:
            # Special case for development user
            if user_id == "dev_user":
                return {
                    "name": "Dev Farmer",
                    "location": {
                        "village": "Model Village",
                        "district": "Pune",
                        "state": "Maharashtra"
                    },
                    "crops": ["Rice", "Wheat", "Sugarcane"],
                    "land_size": "5 Acres",
                    "soil_type": "Black Soil",
                    "irrigation": "Drip Irrigation"
                }

            db = self._get_db()
            doc = db.collection('users').document(user_id).get()
            if doc.exists:
                data = doc.to_dict()
                return {
                    "name": data.get("name", "Farmer"),
                    "location": {
                        "village": data.get("village"),
                        "district": data.get("district"),
                        "state": data.get("state")
                    },
                    "crops": data.get("crops_grown", []) or data.get("mainCrops", []) or [],
                    "land_size": data.get("land_size", "Unknown"),
                    "soil_type": data.get("soil_type", "Unknown"),
                    "irrigation": data.get("irrigation_source", "Unknown")
                }
            return None
        except Exception as e:
            print(f"[NOTIF-ENGINE] DB Error: {e}")
            return None

    def _get_location_string(self, profile: Dict) -> str:
        loc = profile.get("location", {})
        parts = [loc.get("district"), loc.get("state")]
        return ", ".join([p for p in parts if p]) or "India"

    async def _generate_ai_insights(self, profile, weather, news) -> List[Dict]:
        """
        Uses LLM to analyze data and generate specific notifications.
        Returns a list of raw notification dictionaries.
        """
        try:
            with open("d:/Projects/KrishiSahAI TechFiesta/app_debug.log", "a") as logf:
                logf.write(f"[NOTIF-ENGINE] LLM Method Start for {profile.get('name')}\n")
        except: pass
        
        if "error" in weather: weather = {"condition": "Unknown", "temp": "N/A"}
        
        # Format inputs for Prompt
        profile_str = json.dumps(profile, indent=2)
        weather_str = json.dumps(weather, indent=2)
        # Take top 2 news items to save tokens
        news_str = json.dumps(news[:2] if isinstance(news, list) else [], indent=2) 
        
        system_prompt = """
        You are an expert Agricultural Intelligence Engine.
        Your task is to analyze Farmer Profile, Weather Data, and News to generate 3-4 personalized notifications.
        
        STRICT OUTPUT FORMAT:
        Return ONLY a JSON array of objects. No markdown, no conversational text.
        
        Notification Object Structure:
        {
            "title": "Short, urgent title (Max 6 words)",
            "message": "Concise explanation (Max 15 words)",
            "type": "weather" | "pesticide" | "disease" | "market" | "advisory" | "general",
            "priority": "high" | "medium" | "low",
            "action": "One specific, actionable step for the farmer",
            "source": "AI Inference"
        }
        
        RULES:
        1. If rain probability > 60%, generate a HIGH priority 'weather' alert.
        2. If news mentions a pest/disease relevant to the farmer's crops, generate a HIGH priority 'disease' alert.
        3. Include one 'advisory' based on current crop season/weather (e.g., irrigation advice).
        4. Focus on the specified crops: {crops}.
        5. DO NOT use emojis in the title or message.
        """
        
        user_prompt = f"""
        Farmer Profile: {profile_str}
        Weather Data: {weather_str}
        News Data: {news_str}
        
        Generate the notification JSON array now.
        """
        
        try:
            prompt = ChatPromptTemplate.from_messages([
                ("system", system_prompt),
                ("user", user_prompt)
            ])
            
            chain = prompt | self.llm | StrOutputParser()
            
            with open("d:/Projects/KrishiSahAI TechFiesta/app_debug.log", "a") as logf:
                logf.write(f"[NOTIF-ENGINE] Chain prepared. Invoking LLM ({self.llm_model})...\n")
            
            # Now we only need to pass 'crops' as it's the only {var} in the system/user prompt templates
            response = await chain.ainvoke({
                "crops": ", ".join(profile.get('crops', []))
            })
            
            with open("d:/Projects/KrishiSahAI TechFiesta/app_debug.log", "a") as logf:
                logf.write(f"[NOTIF-ENGINE] LLM Response received (len: {len(response)}). Parsing JSON...\n")
                logf.write(f"[NOTIF-ENGINE] RAW RESPONSE: {response}\n")
            
            # Clean up response (remove code blocks if any)
            cleaned = response.strip().replace("```json", "").replace("```", "")
            results = json.loads(cleaned)
            
            with open("d:/Projects/KrishiSahAI TechFiesta/app_debug.log", "a") as logf:
                logf.write(f"[NOTIF-ENGINE] Successfully parsed {len(results)} insights\n")
            
            return results
        except Exception as e:
            import traceback
            error_trace = traceback.format_exc()
            try:
                with open("d:/Projects/KrishiSahAI TechFiesta/app_debug.log", "a") as logf:
                    logf.write(f"[NOTIF-ENGINE] LLM Method ERROR: {str(e)}\n{error_trace}\n")
            except: pass
            print(f"[NOTIF-ENGINE] LLM Method ERROR: {e}")
            return []

    def _process_and_prioritize(self, llm_notifications, weather, news):
        processed = []
        
        # 1. Add LLM generated notifications
        for n in llm_notifications:
            n['id'] = str(datetime.now().timestamp()) + n.get('title', '')[:5]
            n['timestamp'] = datetime.utcnow().isoformat() + "Z"
            n['read'] = False
            processed.append(n)
            
        # 2. Add Critical Weather Alert (Deterministic Fallback)
        # If LLM missed it, but logic says high rain
        rain_prob = weather.get('rainfall_probability', 0)
        try:
            rain_val = float(rain_prob)
            if rain_val > 70:
                has_weather_alert = any(n['type'] == 'weather' and n['priority'] == 'high' for n in processed)
                if not has_weather_alert:
                    processed.append({
                        "id": f"rain_{datetime.now().timestamp()}",
                        "title": "Heavy Rain Alert",
                        "message": f"Rainfall probability is {rain_val}%. Secure your harvested crops.",
                        "type": "weather",
                        "priority": "high",
                        "action": "Do not irrigate. Cover harvested produce.",
                        "source": "Weather API",
                        "timestamp": datetime.utcnow().isoformat() + "Z",
                        "read": False
                    })
        except: pass
        
        # 3. Sort by Priority (High > Medium > Low)
        priority_map = {"high": 0, "medium": 1, "low": 2}
        processed.sort(key=lambda x: priority_map.get(x.get('priority', 'low').lower(), 2))
        
        return processed

    def _store_notifications(self, user_id, notifications):
        self.notification_store[user_id] = notifications

    def get_notifications(self, user_id):
        return self.notification_store.get(user_id, [])

# Singleton Instance
notification_engine = NotificationEngine()
